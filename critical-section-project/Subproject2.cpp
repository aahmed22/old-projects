/* MAT 375 Operating Systems
   Project 3: Subproject 2
   By AbdulHameed Ahmed. */
#include <iostream>
#include <cstdlib> // Needed for the rand and srand functions.
#include <ctime> // Needed for the time function.
#include <fstream> // Needed for file handling and processing.
using namespace std;

void writer1(); // Function prototype for writer 1 process.
void writer2(); // Function prototype for writer 2 process.
void reader1(); // Function prototype for reader 1 process.
void reader2(); // Function prototype for reader 2 process.
void reader3(); // Function prototype for reader 3 process.
void panicMessage(int); // Function prototype for panicMessage, that takes and int argument.
/* Function prototype for Swap which contains two arguments, both
   pointers which point to bool. */
void Swap(bool *, bool *); 

bool lock = false; // lock is of type bool, and initialize to false.

// outputFile is an object of type ofstream. ofstream creates objects for outputting data.
ofstream outputFile;

/* readCount is of type int and initialize to 0. readCount was created to keep track
   of how many readers are in the critical section. */
int readCount = 0;
/* writerCount is of type int and initialize to 0. writerCount was created to keep track
   of writers entering the critical section. */
int writerCount = 0;

int w1Count = 0; // w1Count initialize to 0. w1Count is to keep track of writer 1 activity.
int w2Count = 0; // w2Count initialize to 0. w2Count is to keep track of writer 2 activity.
int r1Count = 0; // r1Count initialize to 0. r1Count is to keep track of reader 1 activity.
int r2Count = 0; // r2Count initialize to 0. r2Count is to keep track of reader 2 activity.
int r3Count = 0; // r3Count initialize to 0. r3Count is to keep track of reader 3 activity.

const int SIZE = 30; // SIZE is of type int and is const. SIZE is initialize to 30.
int buffer[SIZE]; // buffer is an array of type int.

int main()
{
	srand(time(0)); // srand randomizes the random numbers generated by rand, using time function.
	int random; // random is of type int.

	/* outputFile which is an object of type ofstream, is accessing a member function called open
	   which creates "Project 3 Subproject 2 Output.txt" since it does not exist yet. */
	outputFile.open("Project 3 Subproject 2 Output.txt");

    // Each time this loop executes it stores a value inside the buffer.
	for(int i = 0; i < SIZE; i++)
		buffer[i] = i + 1;

	/* This loop iterates 100,000 times. During each iteration it will use the random number generator and
	   store that value inside random. The random variable is defined as only containing values between 1 - 5.
	   Now we proceed to the switch statement. There are 5 cases within the switch statement each case
	   contains a statements that invokes a function call. These function calls are based off of the five
	   processes we are currently trying to run. */
	for(int j = 1; j <= 100000; j++)
	{
		random = rand() % 5 + 1;

		switch(random)
		{
		case 1:
			writer1(); // function call for writer 1 process.
			break;
		case 2:
			writer2(); // function call for writer 2 process.
			break;
		case 3:
			reader1(); // function call for reader 1 process.
			break;
		case 4:
			reader2(); // function call for reader 2 process.
			break;
		case 5:
			reader3(); // function call for reader 3 process.
			break;
		}
	}

	system("pause");
	return 0;
}

// Function defintion for writer 1 process.
void writer1()
{
	// Declared variable called key which is of type bool.
	bool key;

	if(lock == false)
		w1Count++;
	else
		w1Count++;

	/* Within the switch statements contains multiple cases. The first case is called case 1, now case 1
	   contains and if - else statement. The if condition states that if lock equals false, that means there
	   are currently no processes inside the critical section. Since this is true we execute the if block.
	   We assign the value true to key and invoke a function call to Swap. This will update the status of lock
	   to being true, which means when lock is true, there is currently a process inside the critical section.
	   The remaining statements shows that Writer 1 process has successfully enter the critical section and it
	   display which processes are currently inside the critical section. Should the if statement be false
	   then the else statement will execute. Now if the else statements executes this means that there is currently
	   a process inside the critical section and it executes a panic message saying that writer 1 was trying to enter
	   the critical section, while another process was already there. The second case called case 3 shows writer 1 
	   writing data and displays it's output. The last case is called case 5, this case shows writer 1 leaving the
	   critical section, it resets the writer 1's counter to 0, and it assigns the lock value back to false, indicating
	   that writer 1 has left the critical section, it also decrements writerCount. */
	switch(w1Count)
	{
	case 1:
		if(lock == false)
		{
			key = true;
			Swap(&lock, &key);
			
			outputFile << "WRITER 1 HAS ENTERED THE CRITICAL SECTION!\n\n";
			writerCount++;
			outputFile << "THERE ARE CURRENTLY " << writerCount << " WRITER'S AND " << 
			readCount << " READER'S IN THE CRITICAL SECTION!\n\n";
			w1Count++;
        }
		else
        {
			if(readCount > 0)
			{
				panicMessage(1);
				w1Count--;
			}
			else if(w2Count > 0)
			{
				panicMessage(2);
				w1Count--;
			}
		}
		break;
	case 3:
		outputFile << "WRITER 1 IS WRITING DATA! HERE IS WRITER 1 OUTPUT:\n";
		for(int i = 0; i < (SIZE / 2); i++)
			outputFile << buffer[i] << " ";
		outputFile << endl << endl;
		w1Count++;
		break;
	case 5:
		outputFile << "WRITER 1 IS LEAVING THE CRITICAL SECTION!\n\n";
		w1Count = 0;
		lock = false;
		writerCount--;
		break;
	}
}


// Function definition for writer 2 process.
void writer2()
{
	// Declared variable called key which is of type bool.
	bool key;

	if(lock == false)
		w2Count++;
	else
		w2Count++;
	
	/* Within the switch statements contains multiple cases. The first case is called case 1, now case 1
	   contains and if - else statement. The if condition states that if lock equals false, that means there
	   are currently no processes inside the critical section. Since this is true we execute the if block.
	   We assign the value true to key and invoke a function call to Swap. This will update the status of lock
	   to being true, which means when lock is true, there is currently a process inside the critical section.
	   The remaining statements shows that Writer 2 process has successfully enter the critical section and it
	   display which processes are currently inside the critical section. Should the if statement be false
	   then the else statement will execute. Now if the else statements executes this means that there is currently
	   a process inside the critical section and it executes a panic message saying that writer 2 was trying to enter
	   the critical section, while another process was already there. The second case called case 3 shows writer 2 
	   writing data and displays it's output. The last case is called case 5, this case shows writer 2 leaving the
	   critical section, it resets the writer 2's counter to 0, and it assigns the lock value back to false, indicating
	   that writer 2 has left the critical section, it also decrements writerCount. */
	switch(w2Count)
	{
	case 1:
		if(lock == false)
		{
			key = true;
			Swap(&lock, &key);
			
			outputFile << "WRITER 2 HAS ENTERED THE CRITICAL SECTION!\n\n";
			writerCount++;
			outputFile << "THERE ARE CURRENTLY " << writerCount << " WRITER'S AND " << 
			readCount << " READER'S IN THE CRITICAL SECTION!\n\n";
			w2Count++;
        }
		else
        {
			if(readCount > 0)
			{
				panicMessage(3);
				w2Count--;
			}
			else if(w1Count > 0)
			{
				panicMessage(4);
				w2Count--;
			}
		}
		break;
	case 3:
		outputFile << "WRITER 2 IS WRITING DATA! HERE IS WRITER 2 OUTPUT:\n";
		for(int i = (SIZE / 2); i < SIZE; i++)
			outputFile << buffer[i] << " ";
		outputFile << endl << endl;
		w2Count++;
		break;
	case 5:
		outputFile << "WRITER 2 IS LEAVING THE CRITICAL SECTION!\n\n";
		w2Count = 0;
		lock = false;
		writerCount--;
		break;
	}
}


// Function definition for reader 1 process.
void reader1()
{
	// Declared variable called key which is of type bool.
	bool key;
	
	if(lock == false)
		r1Count++;
	else
		r1Count++;

	/* Within the switch statement contains multiple cases. The first case is called case 1, now this case
	   contains a series of selection statements. The first condition is that if lock equals true and both 
	   reader 2 and reader 3 is in the critical section, then issue a panic message. You see only two out 
	   of three readers is allowed inside the critical section, remember when lock equals true that means
	   there is a process or processses inside the critical section. Moving on to the next condition which is
	   for an else if statment, if reader 2 is the only process inside the critical section, then reader 1 is 
	   allowed to enter the critcal section. The next else if condition is similar to the previous
	   one the difference is instead of it being reader 2 it's reader 3 that the only process inside the 
	   critical section, if thats the case then reader 1 is allowed to enter the critical section. The last
	   else if condition is if there are no processes currently inside the critical section, then allow reader 1
	   to enter the critical section, this is done by assigning the value true to key and invoking a function call
	   to Swap. Now lock is updated to true, means a process is currently inside the critical section. Now if none
	   of those conditions are executed, then the else statement will execute, this means that a writer process is 
	   currently inside the critcal section and a panic message will be issued. The second case is called case 3, 
	   this shows reader 1 process reading data and then displaying it's output. The last case called case 5 shows 
	   reader 1 leaving the critcal section, it resets reader 1's counter to 0 and decrements the readCount. Now this 
	   case contains only one if statement, this statement is if readCount is equal to zero, reset lock back to false. 
	   This indicates that no process is currently occupying the critical section. If this condition is false, then lock 
	   will remain true because that means there is still another process occupying the critical section. */
	switch(r1Count)
	{
	case 1:
		if(lock == true && r2Count > 0 && r3Count > 0)
		{
			panicMessage(6);
			r1Count--;
        }
        else if(lock == true && r2Count > 0)
        {
			outputFile << "READER 1 HAS ENTERED THE CRITICAL SECTION!!!\n";
			readCount++;
			outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND " 
				<< writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
			r1Count++;
		}
		else if(lock == true && r3Count > 0)
		{
			outputFile << "READER 1 HAS ENTERED THE CRITICAL SECTION!!!\n";
			readCount++;
			outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND "
				<< writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
			r1Count++;
		}
		else if(lock == false)
		{
			key = true;
			Swap(&lock, &key);
			
			outputFile << "READER 1 HAS ENTERED THE CRITICAL SECTION!!!\n";
			readCount++;
			outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND "
				<< writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
			r1Count++;
		}
		else
		{
			panicMessage(5);
			r1Count--;
		}
		break;
	case 3:
		outputFile << "READING 1 IS READING DATA! HERE IS READER 1 OUTPUT:\n";
		for(int i = 0; i < (SIZE - 20); i++)
			outputFile << buffer[i] << " ";
		outputFile << endl << endl;
		r1Count++;
		break;
	case 5:
		outputFile << "READER 1 IS LEAVING THE CRITICAL SECTION!!\n\n";
		r1Count = 0;
		readCount--;
		if(readCount == 0)
			lock = false;
		break;
	}
}


// Function definition for reader 2 process.
void reader2()
{
	// Declared variable called key which is of type bool.
	bool key;
	
	if(lock == false)
		r2Count++;
	else
		r2Count++;
	
	/* Within the switch statement contains multiple cases. The first case is called case 1, now this case
	   contains a series of selection statements. The first condition is that if lock equals true and both 
	   reader 1 and reader 3 is in the critical section, then issue a panic message. You see only two out 
	   of three readers is allowed inside the critical section, remember when lock equals true that means
	   there is a process or processses inside the critical section. Moving on to the next condition which is
	   for an else if statment, if reader 1 is the only process inside the critical section, then reader 2 is 
	   allowed to enter the critcal section. The next else if condition is similar to the previous
	   one the difference is instead of it being reader 1 it's reader 3 that the only process inside the 
	   critical section, if thats the case then reader 2 is allowed to enter the critical section. The last
	   else if condition is if there are no processes currently inside the critical section, then allow reader 2
	   to enter the critical section, this is done by assigning the value true to key and invoking a function call
	   to Swap. Now lock is updated to true, means a process is currently inside the critical section. Now if none
	   of those conditions are executed, then the else statement will execute, this means that a writer process is 
	   currently inside the critcal section and a panic message will be issued. The second case is called case 3, 
	   this shows reader 2 process reading data and then displaying it's output. The last case called case 5 shows
	   reader 2 leaving the critcal section, it resets reader 2's counter to 0 and decrements the readCount. Now this
	   case contains only one if statement, this statement is if readCount is equal to zero, reset lock back to false.
	   This indicates that no process is currently occupying the critical section. If this condition is false, then 
	   lock will remain true because that means there is still another process occupying the critical section. */
	switch(r2Count)
	{
	case 1:
		if(lock == true && r1Count > 0 && r3Count > 0)
		{
			panicMessage(8);
			r1Count--;
        }
        else if(lock == true && r1Count > 0)
        {
			outputFile << "READER 2 HAS ENTERED THE CRITICAL SECTION!!!\n";
			readCount++;
			outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND " 
				<< writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
			r2Count++;
		}
		else if(lock == true && r3Count > 0)
		{
			outputFile << "READER 2 HAS ENTERED THE CRITICAL SECTION!!!\n";
			readCount++;
			outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND "
				<< writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
			r2Count++;
		}
		else if(lock == false)
		{
			key = true;
			Swap(&lock, &key);
			
			outputFile << "READER 2 HAS ENTERED THE CRITICAL SECTION!!!\n";
			readCount++;
			outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND "
				<< writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
			r2Count++;
		}
		else
		{
			panicMessage(7);
			r2Count--;
		}
		break;
	case 3:
		outputFile << "READING 2 IS READING DATA! HERE IS READER 2 OUTPUT:\n";
		for(int i = (SIZE - 20); i < (SIZE - 10); i++)
			outputFile << buffer[i] << " ";
		outputFile << endl << endl;
		r2Count++;
		break;
	case 5:
		outputFile << "READER 2 IS LEAVING THE CRITICAL SECTION!!\n\n";
		r2Count = 0;
		readCount--;
		if(readCount == 0)
			lock = false;
		break;
	}
}


// Function definition for reader 3 process.
void reader3()
{
	// Declared variable called key which is of type bool.
	bool key;
	
	if(lock == false)
		r3Count++;
	else
		r3Count++;
	
	/* Within the switch statement contains multiple cases. The first case is called case 1, now this case
	   contains a series of selection statements. The first condition is that if lock equals true and both 
	   reader 1 and reader 2 is in the critical section, then issue a panic message. You see only two out 
	   of three readers is allowed inside the critical section, remember when lock equals true that means
	   there is a process or processses inside the critical section. Moving on to the next condition which is
	   for an else if statment, if reader 1 is the only process inside the critical section, then reader 3 is 
	   allowed to enter the critcal section. The next else if condition is similar to the previous
	   one the difference is instead of it being reader 1 it's reader 2 that the only process inside the 
	   critical section, if thats the case then reader 3 is allowed to enter the critical section. The last
	   else if condition is if there are no processes currently inside the critical section, then allow reader 3
	   to enter the critical section, this is done by assigning the value true to key and invoking a function call
	   to Swap. Now lock is updated to true, means a process is currently inside the critical section. Now if none
	   of those conditions are executed, then the else statement will execute, this means that a writer process is 
	   currently inside the critcal section and a panic message will be issued. The second case is called case 3,
	   this shows reader 3 process reading data and then displaying it's output. The last case called case 5 shows
	   reader 3 leaving the critcal section, it resets reader 3's counter to 0 and decrements the readCount. Now this
	   case contains only one if statement, this statement is if readCount is equal to zero, reset lock back to false.
	   This indicates that no process is currently occupying the critical section. If this condition is false, then 
	   lock will remain true because that means there is still another process occupying the critical section. */
	switch(r3Count)
	{
	case 1:
		if(lock == true && r1Count > 0 && r2Count > 0)
		{
			panicMessage(10);
			r3Count--;
        }
        else if(lock == true && r1Count > 0)
        {
			outputFile << "READER 3 HAS ENTERED THE CRITICAL SECTION!!!\n";
			readCount++;
			outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND " 
				<< writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
			r3Count++;
		}
		else if(lock == true && r2Count > 0)
		{
			outputFile << "READER 3 HAS ENTERED THE CRITICAL SECTION!!!\n";
			readCount++;
			outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND "
				<< writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
			r3Count++;
		}
		else if(lock == false)
		{
			key = true;
			Swap(&lock, &key);
			
			outputFile << "READER 3 HAS ENTERED THE CRITICAL SECTION!!!\n";
			readCount++;
			outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND "
				<< writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
			r3Count++;
		}
		else
		{
			panicMessage(9);
			r3Count--;
		}
		break;
	case 3:
		outputFile << "READING 3 IS READING DATA! HERE IS READER 3 OUTPUT:\n";
		for(int i = (SIZE - 10); i < SIZE; i++)
			outputFile << buffer[i] << " ";
		outputFile << endl << endl;
		r3Count++;
		break;
	case 5:
		outputFile << "READER 3 IS LEAVING THE CRITICAL SECTION!!\n\n";
		r3Count = 0;
		readCount--;
		if(readCount == 0)
			lock = false;
		break;
	}
}


/* Function defintion for Swap. Swap takes in two pointers which point to 
   bool, and returns void. Within the function we create a variable called temp of type
   bool and assign it the contents of lock, by dereferencing lock. We then dereference
   key and assign its content to lock, and assign content of temp to key, this is 
   how swapping is implemented. */
void Swap(bool *lock, bool *key)
{
	bool temp = *lock;
	*lock = *key;
	*key = temp;
}


/* Function definition for panicMessage.
   This function executes panic messages for all five process running.
   Each process has two panic messages, these messages notify that 
   another process is trying to enter the critical section. */
void panicMessage(int temp)
{
   switch(temp)
   {
   case 1:
     outputFile << "PANIC MESSAGE!!! WRITER 1 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE READER(S) IS IN THE CRITICAL SECTION!\n\n";
     break;
   case 2:
     outputFile << "PANIC MESSAGE!!! WRITER 1 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE WRITER 2 IS IN THE CRITICAL SECTION!\n\n";
     break;
   case 3:
     outputFile << "PANIC MESSAGE!!! WRITER 2 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE READER(S) IN THE CRITCAL SECTION!\n\n";
     break;
   case 4:
     outputFile << "PANIC MESSAGE!!! WRITER 2 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE WRITER 1 IS IN THE CRITICAL SECTION!\n\n";
     break;
   case 5:
     outputFile << "PANIC MESSAGE!!! READER 1 IS TRYING TO ENTER THE CRITCAL SECTION, WHILE WRITER(S) IS IN THE CRITICAL SECITON!\n\n";
     break;
   case 6:
     outputFile << "PANIC MESSAGE!!! READER 1 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE READER'S 2 & 3 ARE IN THE CRITICAL SECTION!\n\n";
     break;
   case 7:
     outputFile << "PANIC MESSAGE!!! READER 2 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE WRITER(S) IS IN THE CRITICAL SECTION!\n\n";
     break;
   case 8:
     outputFile << "PANIC MESSAGE!!! READER 2 IS TRYING TO ENTER THE CRITCAL SECTION, WHILE READER'S 1 & 3 ARE IN THE CRITCAL SECTION!\n\n";
     break;
   case 9:
     outputFile << "PANIC MESSAGE!!! READER 3 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE WRITER(S) IS IN THE CRITICAL SECTION!\n\n";
     break;
   case 10:
     outputFile << "PANIC MESSAGE!!! READER 3 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE READER'S 1 & 2 ARE IN THE CRITICAL SECTION!\n\n";
     break;
   }
}