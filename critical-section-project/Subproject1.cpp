/* MAT 375 Operating Systems
   Project 3: Subproject 1
   By AbdulHameed Ahmed. */
#include <iostream>
#include <cstdlib> // Needed for the rand and srand functions.
#include <ctime> // Needed for the time function.
#include <fstream> // Needed for file handling and processing.
using namespace std;

void writer1(); // Function prototype for writer 1 process.
void writer2(); // Function prototype for writer 2 process.
void reader1(); // Function prototype for reader 1 process.
void reader2(); // Function prototype for reader 2 process.
void reader3(); // Function prototype for reader 3 process.
void panicMessage(int); // Function prototype for panicMessage.

// outputFile is an object of type ofstream. ofstream creates objects for outputting data.
ofstream outputFile;

/* readCount is of type int and initialize to 0. readCount was created to keep track
   of how many readers are in the critical section. */
int readCount = 0;
/* writerCount is of type int and initialize to 0. writerCount was created to keep track
   of writers entering the critical section. */
int writerCount = 0;

int w1Count = 0; // w1Count initialize to 0. w1Count is to keep track of writer 1 activity.
int w2Count = 0; // w2Count initialize to 0. w2Count is to keep track of writer 2 activity.
int r1Count = 0; // r1Count initialize to 0. r1Count is to keep track of reader 1 activity.
int r2Count = 0; // r2Count initialize to 0. r2Count is to keep track of reader 2 activity.
int r3Count = 0; // r3Count initialize to 0. r3Count is to keep track of reader 3 activity.

const int SIZE = 30; // SIZE is of type int and is const. SIZE is initialize to 30.
int buffer[SIZE]; // buffer is an array of type int.


int main()
{
	srand(time(0)); // srand randomizes the random numbers generated by rand, using time function.
	int random; // random is of type int.

	/* outputFile which is an object of type ofstream, is accessing a member function called open
	   which creates "Project 3 Subproject 1 Output.txt" since it does not exist yet. */
	outputFile.open("Project 3 Subproject 1 Output.txt");

    // Each time this loop executes it stores a value inside the buffer.
	for(int i = 0; i < SIZE; i++)
		buffer[i] = i + 1;

	/* This loop iterates 100,000 times. During each iteration it will use the random number generator and
	   store that value inside random. The random variable is defined as only containing values between 1 - 5.
	   Now we proceed to the switch statement. There are 5 cases within the switch statement each case
	   contains a statements that invokes a function call. These function calls are based off of the five
	   processes we are currently trying to run. */
	for(int j = 1; j <= 100000; j++)
	{
		random = rand() % 5 + 1;

		switch(random)
		{
		case 1:
			writer1(); // function call for writer 1 process.
			break;
		case 2:
			writer2(); // function call for writer 2 process.
			break;
		case 3:
			reader1(); // function call for reader 1 process.
			break;
		case 4:
			reader2(); // function call for reader 2 process.
			break;
		case 5:
			reader3(); // function call for reader 3 process.
			break;
		}
	}

	system("pause");
	return 0;
}


// Function definition for writer 1 process.
void writer1()
{
	/* If there are no writers in the critical section increment writer 1's counter,
	   so it can enter the critical section. */
	if(writerCount == 0)
		w1Count++;
	else
		w1Count++;

	/* Below we have multiple cases for writer 1 process. The frist case is called case 1, which
	   is defined as showing when writer 1 enters the critical section and displaying the current 
	   amount of writer's and reader's in the critical section. The second case is called case 3,
	   which is defined as showing when writer 1 is writing data and displays its output.
	   The last case called case 5, is defined as showing when writer 1 is leaving the critical section. */
	switch(w1Count)
	{
	case 1:
		/* We first check to see if there are any readers in the critical section,
		   if there are reader's currently in the critical section, execute a panic message. */
		if(readCount > 0)
		{
			panicMessage(1);
			w1Count--;
		}
		// If writer 2 happens to already be in the critical section, then issue a panic message.
		else if(w2Count > 0)
		{
			panicMessage(2);
			w1Count--;
		}
		// Assuming that there is no other process inside the critical section, then we execute this else block statement.
		else
		{
			outputFile << "WRITER 1 HAS ENTERED THE CRITICAL SECTION!\n\n";
			writerCount++;
			outputFile << "THERE ARE CURRTENLY " << writerCount << " WRITER'S AND " << readCount
				<< " READER'S IN THE CRITICAL SECTION!\n\n";
			w1Count++;
		}
		break;
	case 3:
		/* These statement's when executed shows writer 1 is currently writing data
		   then it displays it's output. */
		outputFile << "WRITER 1 IS WRITING DATA! HERE IS WRITER 1 OUTPUT:\n";
		for(int i = 0; i < (SIZE / 2); i++)
			outputFile << buffer[i] << " ";
		outputFile << endl << endl;
		w1Count++;
		break;
	case 5:
		/* The following statements display writer 1 leaving the critical section,
		   and it reset's writer 1 counter to 0, and also decrements the writerCount. */
		outputFile << "WRITER 1 IS LEAVING THE CRITICAL SECTION!\n\n";
		w1Count = 0;
		writerCount--;
		break;
	}
}
			

// Function definition for writer 2 process.
void writer2()
{
	/* If there are no writers in the critical section increment writer 2's counter,
	   so it can enter the critical section. */
	if(writerCount == 0)
		w2Count++;
	else
		w2Count++;

	/* Below we have multiple cases for writer 2 process. The frist case is called case 1, which
	   is defined as showing when writer 2 enters the critical section and displaying the current 
	   amount of writer's and reader's in the critical section. The second case is called case 3,
	   which is defined as showing when writer 2 is writing data and displays its output.
	   The last case called case 5, is defined as showing when writer 2 is leaving the critical section. */
	switch(w2Count)
	{
	case 1:
		/* We first check to see if there are any readers in the critical section,
		   if there are reader's currently in the critical section, execute a panic message. */
		if(readCount > 0)
		{
			panicMessage(3);
			w2Count--;
		}
		// If writer 1 happens to already be in the critical section, then issue a panic message.
		else if(w1Count > 0)
		{
			panicMessage(4);
			w2Count--;
		}
		// Assuming that there is no other process inside the critical section, then we execute this else block statement.
		else
		{
			outputFile << "WRITER 2 HAS ENTERED THE CRITCAL SECTION!\n\n";
			writerCount++;
			outputFile << "THERE ARE CURRENTLY " << writerCount << " WRITER'S AND " << readCount
				<< " READER'S IN THE CRITICAL SECTION!\n\n";
			w2Count++;
		}
		break;
	case 3:
		/* These statement's when executed shows writer 2 is currently writing data
		   then it displays it's output. */
		outputFile << "WRITER 2 IS WRITING DATA! HERE IS WRITER 2 OUTPUT:\n";
		for(int i = (SIZE / 2); i < SIZE; i++)
			outputFile << buffer[i] << " ";
		outputFile << endl << endl;
		w2Count++;
		break;
	case 5:
		/* The following statements display writer 2 leaving the critical section,
		   and it reset's writer 2 counter to 0, and also decrements the writerCount. */
		outputFile << "WRITER 2 IS LEAVING THE CRITICAL SECTION!\n\n";
		w2Count = 0;
		writerCount--;
		break;
	}
}


// Function definition for reader 1 process.
void reader1()
{
	/* If there are no reader's in the critical section, then increment reader 1's counter
	   so that it can enter the critical section. */
   if(readCount == 0)
     r1Count++;
   else
	   r1Count++;

   /* Below we have multiple cases for reader 1 process.The first case called case 1 is defined with the following conditions:
      if there is any writers currently in the critical section then issue a PANIC MESSAGE!. The next condition is if 
	  both reader 2 and reader 3 is already in the critical section then issue a PANIC MESSAGE!. The next condition after
	  that is if reader 2 is the only process in the critical section, then reader 1 is allowed to enter.The following 
	  condition after that is similar to the previous one, except it's reader 3 that's the only process in the critical section,
	  and reader 1 is allowed to enter. The else statement within case 1 is the last condition which is assuming no other process
	  is in the critical section, then reader 1 can enter the critical section. The second case called case 3, when executed shows 
	  reader 1 reading data and also displays its output. The last case which is called case 5, shows when reader 1 is leaving 
	  the critical section, it also resets reader 1 counter to 0, and also decrements readCount */
   switch(r1Count)
   {
   case 1:
      if(writerCount > 0)
	  {
		  panicMessage(5);
		  r1Count--;
	  }
      else if(r2Count > 0 && r3Count > 0)
	  {
		  panicMessage(6);
		  r1Count--;
	  }
	  else if(r2Count > 0)
	  {
		  outputFile << "READER 1 HAS ENTERED THE CRITICAL SECTION!!!\n";
		  readCount++;
		  outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND " << writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
		  r1Count++;
	  }
	  else if(r3Count > 0)
	  {
		  outputFile << "READER 1 HAS ENTERED THE CRITICAL SECTION!!!\n";
		  readCount++;
		  outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND " << writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
		  r1Count++;
	  }
      else
      {
		  outputFile << "READER 1 HAS ENTERED THE CRITICAL SECTION!!!\n";
		  readCount++;
		  outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND " << writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
		  r1Count++;
      }
      break;
   case 3:
	   outputFile << "READING 1 IS READING DATA! HERE IS READER 1 OUTPUT:\n";
	   for(int i = 0; i < (SIZE - 20); i++)
		   outputFile << buffer[i] << " ";
	   outputFile << endl << endl;
	   r1Count++;
	   break;
   case 5:
	   outputFile << "READER 1 IS LEAVING THE CRITICAL SECTION!!\n\n";
	   r1Count = 0;
	   readCount--;
	   break;
   }
}


// Function definition for reader 2 process.
void reader2()
{
	/* If there are no reader's in the critical section, then increment reader 2's counter
	   so that it can enter the critical section. */
   if(readCount == 0)
     r2Count++;
   else
	   r2Count++;

   /* Below we have multiple cases for reader 2 process.The first case called case 1 is defined with the following conditions:
      if there is any writers currently in the critical section then issue a PANIC MESSAGE!. The next condition is if 
	  both reader 1 and reader 3 is already in the critical section then issue a PANIC MESSAGE!. The next condition after
	  that is if reader 1 is the only process in the critical section, then reader 2 is allowed to enter.The following 
	  condition after that is similar to the previous one, except it's reader 3 that's the only process in the critical section,
	  and reader 2 is allowed to enter. The else statement within case 1 is the last condition which is assuming no other process
	  is in the critical section, then reader 2 can enter the critical section. The second case called case 3, when executed shows 
	  reader 2 reading data and also displays its output. The last case which is called case 5, shows when reader 2 is leaving 
	  the critical section, it also resets reader 2 counter to 0, and also decrements readCount */
   switch(r2Count)
   {
   case 1:
      if(writerCount > 0)
	  {
		  panicMessage(7);
		  r2Count--;
	  }
      else if(r1Count > 0 && r3Count > 0)
	  {
		  panicMessage(8);
		  r2Count--;
	  }
	  else if(r1Count > 0)
	  {
		  outputFile << "READER 2 HAS ENTERED THE CRITICAL SECTION!!!\n";
		  readCount++;
		  outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND " << writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
		  r2Count++;
	  }
	  else if(r3Count > 0)
	  {
		  outputFile << "READER 2 HAS ENTERED THE CRITICAL SECTION!!!\n";
		  readCount++;
		  outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND " << writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
		  r2Count++;
	  }
      else
      {
		  outputFile << "READER 2 HAS ENTERED THE CRITICAL SECTION!!!\n";
		  readCount++;
		  outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND " << writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
		  r2Count++;
      }
      break;
   case 3:
	   outputFile << "READER 2 IS READING DATA! HERE IS READER 2 OUTPUT:\n";
	   for(int i = (SIZE - 20); i < (SIZE - 10); i++)
		   outputFile << buffer[i] << " ";
	   outputFile << endl << endl;
	   r2Count++;
	   break;
   case 5:
	   outputFile << "READER 2 IS LEAVING THE CRITICAL SECTION!!\n\n";
	   r2Count = 0;
	   readCount--;
	   break;
   }
}


// Function definition for reader 3 process.
void reader3()
{
	/* If there are no reader's in the critical section, then increment reader 3's counter
	   so that it can enter the critical section. */
   if(readCount == 0)
     r3Count++;
   else
	   r3Count++;

   /* Below we have multiple cases for reader 3 process.The first case called case 1 is defined with the following conditions:
      if there is any writers currently in the critical section then issue a PANIC MESSAGE!. The next condition is if 
	  both reader 1 and reader 2 is already in the critical section then issue a PANIC MESSAGE!. The next condition after
	  that is if reader 1 is the only process in the critical section, then reader 3 is allowed to enter.The following 
	  condition after that is similar to the previous one, except it's reader 2 that's the only process in the critical section,
	  and reader 3 is allowed to enter. The else statement within case 1 is the last condition which is assuming no other process 
	  is in the critical section, then reader 3 can enter the critical section. The second case called case 3, when executed shows 
	  reader 3 reading data and also displays its output. The last case which is called case 5, shows when reader 3 is leaving 
	  the critical section, it also resets reader 3 counter to 0, and also decrements readCount */
   switch(r3Count)
   {
   case 1:
      if(writerCount > 0)
	  {
		  panicMessage(9);
		  r3Count--;
	  }
      else if(r1Count > 0 && r2Count > 0)
	  {
		  panicMessage(10);
		  r3Count--;
	  }
	  else if(r1Count > 0)
	  {
		  outputFile << "READER 3 HAS ENTERED THE CRITICAL SECTION!!!\n";
		  readCount++;
		  outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND " << writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
		  r3Count++;
	  }
	  else if(r2Count > 0)
	  {
		  outputFile << "READER 3 HAS ENTERED THE CRITICAL SECTION!!!\n";
		  readCount++;
		  outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND " << writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
		  r3Count++;
	  }
      else
      {
		  outputFile << "READER 3 HAS ENTERED THE CRITICAL SECTION!!!\n";
		  readCount++;
		  outputFile << "THERE ARE CURRENTLY " << readCount << " READER'S AND " << writerCount << " WRITER'S IN THE CRITICAL SECTION!\n\n";
		  r3Count++;
      }
      break;
   case 3:
	   outputFile << "READER 3 IS READING DATA! HERE IS READER 3 OUTPUT:\n";
       for(int i = (SIZE - 10); i < SIZE; i++)
               outputFile << buffer[i] << " ";
       outputFile << endl << endl;
       r3Count++;
	   break;
   case 5:
	   outputFile << "READER 3 IS LEAVING THE CRITICAL SECTION!!\n\n";
	   r3Count = 0;
	   readCount--;
	   break;
   }
}


/* Function definition for panicMessage.
   This function executes panic messages for all five process running.
   Each process has two panic messages, these messages notify that 
   another process is trying to enter the critical section. */
void panicMessage(int temp)
{
   switch(temp)
   {
   case 1:
     outputFile << "PANIC MESSAGE!!! WRITER 1 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE READER(S) IS IN THE CRITICAL SECTION!\n\n";
     break;
   case 2:
     outputFile << "PANIC MESSAGE!!! WRITER 1 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE WRITER 2 IS IN THE CRITICAL SECTION!\n\n";
     break;
   case 3:
     outputFile << "PANIC MESSAGE!!! WRITER 2 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE READER(S) IN THE CRITCAL SECTION!\n\n";
     break;
   case 4:
     outputFile << "PANIC MESSAGE!!! WRITER 2 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE WRITER 1 IS IN THE CRITICAL SECTION!\n\n";
     break;
   case 5:
     outputFile << "PANIC MESSAGE!!! READER 1 IS TRYING TO ENTER THE CRITCAL SECTION, WHILE WRITER(S) IS IN THE CRITICAL SECITON!\n\n";
     break;
   case 6:
     outputFile << "PANIC MESSAGE!!! READER 1 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE READER'S 2 & 3 ARE IN THE CRITICAL SECTION!\n\n";
     break;
   case 7:
     outputFile << "PANIC MESSAGE!!! READER 2 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE WRITER(S) IS IN THE CRITICAL SECTION!\n\n";
     break;
   case 8:
     outputFile << "PANIC MESSAGE!!! READER 2 IS TRYING TO ENTER THE CRITCAL SECTION, WHILE READER'S 1 & 3 ARE IN THE CRITCAL SECTION!\n\n";
     break;
   case 9:
     outputFile << "PANIC MESSAGE!!! READER 3 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE WRITER(S) IS IN THE CRITICAL SECTION!\n\n";
     break;
   case 10:
     outputFile << "PANIC MESSAGE!!! READER 3 IS TRYING TO ENTER THE CRITICAL SECTION, WHILE READER'S 1 & 2 ARE IN THE CRITICAL SECTION!\n\n";
     break;
   }
}